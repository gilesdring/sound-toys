---
layout: layouts/base.njk
title: XY Theremin
---
<aside>
  <p>Click or touch on the grey area play.</p>
  <p>Move left and right to change pitch.</p>
  <p>Move up and down to change volume.</p>
  <p>Click again or release your finger to stop.</p>
</aside>
<main role="main">
  <div id="control-surface"></div>
  <section id="visualisation">
    <canvas id="waveform"></canvas>
    <canvas id="oscilloscope"></canvas>
  </section>
</main>
<script>
  (function () {
    var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const sampleRate = audioCtx.sampleRate;

    var myArrayBuffer = audioCtx.createBuffer(2, sampleRate, sampleRate);
    var gainNode = audioCtx.createGain();
    gainNode.connect(audioCtx.destination);
    let playbackRateAdjustment = 1;

    /**
     * Sine wave generator function
     */
    function* sineGen(frequency, sampleRate) {
      playbackRateAdjustment = 1;
      const r = sampleRate || audioCtx.sampleRate;
      let step = 0;
      const segment = 2 * Math.PI / r * frequency;
      do {
        yield Math.sin(step * segment);
        step++;
      } while (true)
    }

    /**
     * Square wave generator
     */
    function* squareGen(frequency, sampleRate) {
      const r = sampleRate || audioCtx.sampleRate;
      playbackRateAdjustment = 1;
      let step = 0;
      const w = r / frequency;
      do {
        yield (step % w) / w < 0.5 ? 1 : -1;
        step++;
      } while (true)
    }

    /**
     * Create wave from a wavetable
     * It's a small step from here to...
     */
    function* waveTableGen(frequency, sampleRate) {
      const scale = 32;
      const size = (sampleRate || audioCtx.sampleRate) / scale;
      playbackRateAdjustment = frequency / scale;

      // Create and fill buffer with wave
      const buffer = new Float32Array(size);
      const wtf = (i) => { // Wave Table Function
        return 0.5 * Math.sin(2 * Math.PI * i / size) +
          0.45 * Math.sin(4 * Math.PI * i / size) +
          0.3 * Math.sin(6 * Math.PI * i / size);
      }
      for (let i = 0; i < size; i++) buffer[i] = wtf(i);

      // Loop round the buffer
      let step = 0;
      while (true) {
        yield buffer[step % size];
        step++;
      }
    }

    /**
     * Create fundamental reference wave - set to A440
     */
    const wave = waveTableGen(440);

    for (var channel = 0; channel < myArrayBuffer.numberOfChannels; channel++) {
      // This gives us the actual array that contains the data
      var nowBuffering = myArrayBuffer.getChannelData(channel);
      for (var i = 0; i < myArrayBuffer.length; i++) {
        nowBuffering[i] = wave.next().value;
      }
    }

    /**
     * Factory which returns an octave scaler - converts a number from 0->1 to
     * a multipler from 1 to 2^octaveRange
     */
    const octaveScaler = (octaveRange, minOctave = 0) => (value) => 2 ** ((value * octaveRange) + minOctave);

    let source;
    const play = () => {
      if (Boolean(source)) source.stop();
      source = audioCtx.createBufferSource();
      source.loop = true;
      source.buffer = myArrayBuffer;
      source.connect(gainNode);
      source.start();
    }
    const stop = () => source.stop();

    const pitchRange = octaveScaler(3, -3);

    const setPitchAndVolume = (e) => {
      e.preventDefault();
      if (!Boolean(source)) return;
      var shape = e.target.getBoundingClientRect();
      var xPos = e.pageX || e.touches[0].clientX;
      var yPos = e.pageY || e.touches[0].clientX;
      var pos = {
        x: xPos - shape.left,
        y: yPos - shape.top,
      }
      const freq = pitchRange(pos.x / shape.width);
      const gain = 1 - (pos.y / shape.height);
      source.playbackRate.value = freq * playbackRateAdjustment;
      gainNode.gain.value = gain;
    }
    let playing;
    const toggle = () => {
      if (!Boolean(playing)) {
        playing = true;
        play();
      } else {
        playing = false;
        stop();
      }
    }

    document.querySelector('#control-surface').addEventListener("click", (e) => { toggle(); setPitchAndVolume(e); });
    document.querySelector('#control-surface').addEventListener("mousemove", (e) => setPitchAndVolume(e));
    document.querySelector('#control-surface').addEventListener("touchstart", (e) => { play(); setPitchAndVolume(e); });
    document.querySelector('#control-surface').addEventListener("touchmove", (e) => { setPitchAndVolume(e); });
    document.querySelector('#control-surface').addEventListener("touchend", (e) => { stop(); });

    const analyser = audioCtx.createAnalyser();

    const canvas = document.getElementById('oscilloscope');
    const canvasCtx = canvas.getContext('2d');
    gainNode.connect(analyser);

    function visualize(displayType = "waveform") {
      WIDTH = canvas.width;
      HEIGHT = canvas.height;

      if (displayType === "waveform") {
        analyser.fftSize = 4096;
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        canvasCtx.clearRect(0, 0, WIDTH, HEIGHT);
        var draw = function () {
          drawVisual = requestAnimationFrame(draw);
          analyser.getByteTimeDomainData(dataArray);
          canvasCtx.fillStyle = 'rgb(0, 100, 0)';
          canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);
          canvasCtx.lineWidth = 2;
          canvasCtx.strokeStyle = 'rgb(0, 255, 0)';
          canvasCtx.beginPath();

          var sliceWidth = WIDTH * 3 / bufferLength;
          var x = 0;

          let triggered = false;
          for (var i = 0; i < bufferLength; i++) {
            triggered = true;
            var v = dataArray[i] / 128.0;
            var y = v * HEIGHT / 2;

            if (i === 0) {
              canvasCtx.moveTo(x, y);
            } else {
              canvasCtx.lineTo(x, y);
            }

            x += sliceWidth;
            if (x > WIDTH) break;
          }

          canvasCtx.lineTo(canvas.width, canvas.height / 2);
          canvasCtx.stroke();
        };

        draw();

      }
      else if (displayType == "frequencybars") {
        analyser.fftSize = 256;
        var bufferLengthAlt = analyser.frequencyBinCount;
        console.log(bufferLengthAlt);
        var dataArrayAlt = new Uint8Array(bufferLengthAlt);

        canvasCtx.clearRect(0, 0, WIDTH, HEIGHT);

        var drawAlt = function () {
          drawVisual = requestAnimationFrame(drawAlt);

          analyser.getByteFrequencyData(dataArrayAlt);

          canvasCtx.fillStyle = 'rgb(0, 0, 0)';
          canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);

          var barWidth = (WIDTH / bufferLengthAlt) * 2.5;
          var barHeight;
          var x = 0;

          for (var i = 0; i < bufferLengthAlt; i++) {
            barHeight = dataArrayAlt[i];

            canvasCtx.fillStyle = 'rgb(' + (barHeight + 100) + ',50,50)';
            canvasCtx.fillRect(x, HEIGHT - barHeight / 2, barWidth, barHeight / 2);

            x += barWidth + 1;
          }
        };

        drawAlt();

      }
      else if (displayType == "off") {
        canvasCtx.clearRect(0, 0, WIDTH, HEIGHT);
        canvasCtx.fillStyle = "red";
        canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);
      }
    }
    visualize("waveform");

    const displayWaveform = (id) => {
      const canvas = document.getElementById(id);
      const canvasCtx = canvas.getContext('2d');
      WIDTH = canvas.width;
      HEIGHT = canvas.height;
      canvasCtx.clearRect(0, 0, WIDTH, HEIGHT);

      const sliceWidth = WIDTH * 220 / playbackRateAdjustment / myArrayBuffer.length;

      const data = myArrayBuffer.getChannelData(0);
      canvasCtx.lineWidth = 5;
      canvasCtx.strokeStyle = 'rgb(200, 245, 200)';
      canvasCtx.beginPath();

      for (let i = 0; i < myArrayBuffer.length; i++) {
        const y = ((1 - (data[i] * 0.9))) * HEIGHT / 2;
        const x = i * sliceWidth;

        if (i === 0) {
          canvasCtx.moveTo(x, y);
        } else {
          canvasCtx.lineTo(x, y);
        }
        if (x > WIDTH) break;
      }
      canvasCtx.stroke();
    };
    displayWaveform("waveform");
  })();
</script>