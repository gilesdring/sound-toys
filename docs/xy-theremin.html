<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SOUNDTOYS :: XY THEREMIN</title>
  <style>
    * {
      font-family: monospace;
      margin: 0;
      padding: 0;
    }

    #control-surface {
      /* width: 100%; */
      height: 400px;
      background: grey;
    }

    #visualizer {
      width: 100%;
      height: 100px;
      padding-top: 10px;
    }

    body>* {
      margin-left: auto;
      margin-right: auto;
      padding: 0.5em 1em;
      background: orange;
      max-width: 500px;
    }

    main {
      padding: 1em;
    }
  </style>
</head>

<body>
  <header>
    <h1>XY THEREMIN</h1>
  </header>
  <aside>
    <p>Click or touch on the grey area play.</p>
    <p>Move left and right to change pitch.</p>
    <p>Move up and down to change volume.</p>
    <p>Click again or release your finger to stop.</p>
  </aside>
  <main role="main">
    <div id="control-surface"></div>
    <canvas id="visualizer"></canvas>
  </main>
  <script>
    (function () {
      var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const sampleRate = audioCtx.sampleRate;

      var myArrayBuffer = audioCtx.createBuffer(2, sampleRate, sampleRate);
      var gainNode = audioCtx.createGain();
      gainNode.connect(audioCtx.destination);

      /**
       * Sine wave generator function
       */
      function* sineGen(frequency, sampleRate) {
        const r = sampleRate || audioCtx.sampleRate;
        let step = 0;
        const segment = Math.PI / r * frequency;
        do {
          yield Math.sin(step * segment);
          step++;
        } while (true)
      }

      /**
       * Square wave generator
       */
      function* squareGen(frequency, sampleRate) {
        const r = sampleRate || audioCtx.sampleRate;
        let step = 0;
        const w = r / frequency;
        do {
          yield (step % w) / w < 0.5 ? 1 : -1;
          step++;
        } while (true)
      }

      /**
       * Create fundamental reference wave - set to A440
       */
      const wave = squareGen(440);

      for (var channel = 0; channel < myArrayBuffer.numberOfChannels; channel++) {
        // This gives us the actual array that contains the data
        var nowBuffering = myArrayBuffer.getChannelData(channel);
        for (var i = 0; i < myArrayBuffer.length; i++) {
          nowBuffering[i] = wave.next().value;
        }
      }

      /**
       * Factory which returns an octave scaler - converts a number from 0->1 to
       * a multipler from 1 to 2^octaveRange
       */
      const octaveScaler = (octaveRange, minOctave = 0) => (value) => 2 ** ((value * octaveRange) + minOctave);

      let source;
      const play = () => {
        if (Boolean(source)) source.stop();
        source = audioCtx.createBufferSource();
        source.loop = true;
        source.buffer = myArrayBuffer;
        source.connect(gainNode);
        source.start();
      }
      const stop = () => source.stop();

      const pitchRange = octaveScaler(3, -3);

      const setPitchAndVolume = (e) => {
        e.preventDefault();
        if (!Boolean(source)) return;
        var shape = e.target.getBoundingClientRect();
        var xPos = e.pageX || e.touches[0].clientX;
        var yPos = e.pageY || e.touches[0].clientX;
        var pos = {
          x: xPos - shape.left,
          y: yPos - shape.top,
        }
        const freq = pitchRange(pos.x / shape.width);
        const gain = 1 - (pos.y / shape.height);
        source.playbackRate.value = freq;
        gainNode.gain.value = gain;
      }
      let playing;
      const toggle = () => {
        if (!Boolean(playing)) {
          playing = true;
          play();
        } else {
          playing = false;
          stop();
        }
      }

      document.querySelector('#control-surface').addEventListener("click", (e) => { toggle(); setPitchAndVolume(e); });
      document.querySelector('#control-surface').addEventListener("mousemove", (e) => setPitchAndVolume(e));
      document.querySelector('#control-surface').addEventListener("touchstart", (e) => { play(); setPitchAndVolume(e); });
      document.querySelector('#control-surface').addEventListener("touchmove", (e) => { setPitchAndVolume(e); });
      document.querySelector('#control-surface').addEventListener("touchend", (e) => { stop(); });

      const analyser = audioCtx.createAnalyser();

      const canvas = document.getElementById('visualizer');
      const canvasCtx = canvas.getContext('2d');
      gainNode.connect(analyser);

      function visualize(displayType = "waveform") {
        WIDTH = canvas.width;
        HEIGHT = canvas.height;

        if (displayType === "waveform") {
          analyser.fftSize = 4096;
          const bufferLength = analyser.frequencyBinCount;
          const dataArray = new Uint8Array(bufferLength);
          canvasCtx.clearRect(0, 0, WIDTH, HEIGHT);
          var draw = function () {
            drawVisual = requestAnimationFrame(draw);
            analyser.getByteTimeDomainData(dataArray);
            canvasCtx.fillStyle = 'rgb(0, 100, 0)';
            canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);
            canvasCtx.lineWidth = 2;
            canvasCtx.strokeStyle = 'rgb(0, 255, 0)';
            canvasCtx.beginPath();

            var sliceWidth = WIDTH * 3 / bufferLength;
            var x = 0;

            let triggered = false;
            for (var i = 0; i < bufferLength; i++) {
              triggered = true;
              var v = dataArray[i] / 128.0;
              var y = v * HEIGHT / 2;

              if (i === 0) {
                canvasCtx.moveTo(x, y);
              } else {
                canvasCtx.lineTo(x, y);
              }

              x += sliceWidth;
              if (x > WIDTH) break;
            }

            canvasCtx.lineTo(canvas.width, canvas.height / 2);
            canvasCtx.stroke();
          };

          draw();

        }
        else if (displayType == "frequencybars") {
          analyser.fftSize = 256;
          var bufferLengthAlt = analyser.frequencyBinCount;
          console.log(bufferLengthAlt);
          var dataArrayAlt = new Uint8Array(bufferLengthAlt);

          canvasCtx.clearRect(0, 0, WIDTH, HEIGHT);

          var drawAlt = function () {
            drawVisual = requestAnimationFrame(drawAlt);

            analyser.getByteFrequencyData(dataArrayAlt);

            canvasCtx.fillStyle = 'rgb(0, 0, 0)';
            canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);

            var barWidth = (WIDTH / bufferLengthAlt) * 2.5;
            var barHeight;
            var x = 0;

            for (var i = 0; i < bufferLengthAlt; i++) {
              barHeight = dataArrayAlt[i];

              canvasCtx.fillStyle = 'rgb(' + (barHeight + 100) + ',50,50)';
              canvasCtx.fillRect(x, HEIGHT - barHeight / 2, barWidth, barHeight / 2);

              x += barWidth + 1;
            }
          };

          drawAlt();

        }
        else if (displayType == "off") {
          canvasCtx.clearRect(0, 0, WIDTH, HEIGHT);
          canvasCtx.fillStyle = "red";
          canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);
        }
      }
      visualize("waveform");
    })();
  </script>
</body>

</html>